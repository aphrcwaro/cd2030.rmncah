#' Plot Private Sector Prevalence by Sector and Area/National Level
#'
#' Generates a stacked bar chart for RMNCAH indicators comparing public vs. private sector
#' share by either national or area-level (urban/rural) estimates.
#'
#' @param x A data frame of class `"cd_private_sector_plot_data"` generated by
#'   [prepare_private_sector_plot_data()].
#' @param ... Reserved for future use.
#' @param country_name Optional character string to override the default country name used
#'   in the plot title. If `NULL`, uses the unique value in the `country` column if present.
#'
#' @return A `ggplot` object with:
#'   - Stacked bars for public/private sector share
#'   - Facets by indicator for area-level plots
#'   - Annotated private sector shares as text labels
#'
#' @details
#' The function automatically detects whether the data is at the `"national"` or `"area"`
#' level using the `"level"` attribute. It:
#'
#' - Maps indicator codes to descriptive labels
#' - Stacks `r_raw_Public` and `r_raw_Private` values
#' - Adds text annotations for private sector shares
#'
#' For area-level data, bars are grouped by `area` and faceted by indicator.
#' For national-level data, each indicator has a single stacked bar.
#'
#' @examples
#' \dontrun{
#' dt <- load_private_sector_data("Area estimates.dta", country_iso = "TZA", level = "area")
#' cs <- load_csection_estimates("csection_area.dta", country_iso = "TZA", level = "area")
#' plot_data <- prepare_private_sector_plot_data(dt, cs)
#' plot(plot_data)
#' }
#'
#' @export
plot.cd_private_sector_plot_data <- function(x, ..., country_name = NULL) {
  data_level <- attr_or_abort(x, "level")
  data_level_col <- if (data_level == "area") 'area' else NULL

  # Determine country name for plot title
  if (is.null(country_name)) {
    if ("country" %in% names(x) && length(unique(x$country)) == 1) {
      country_name <- unique(x$country)
    } else {
      country_name <- "Prevalence" # Default if country not singular or missing
    }
  }

  # Prepare base data for plotting and labels
  plot_df_base <- x %>%
    filter(indic %in% c("careany", "csection", "ideliv")) %>%
    mutate(
      # Map indic to more descriptive labels as factors for consistent order
      indic_label = dplyr::case_match(
        indic,
        "careany" ~ "Careseeking for child illness",
        "csection" ~ "C-section",
        "ideliv" ~ "Institutional delivery",
        .ptype = factor(levels = c("Careseeking for child illness", "C-section", "Institutional delivery"))
      )
    )

  # Create long format data for stacked bars
  long_df <- plot_df_base %>%
    select(indic_label, starts_with("r_raw_"), all_of(data_level_col)) %>%
    pivot_longer(
      cols = starts_with("r_raw_"),
      names_to = "sector",
      names_prefix = "r_raw_",
      values_to = "value"
    ) %>%
    mutate(
      sector = factor(sector, levels = c("Public", "Private"))
    )

  # Prepare label data for text annotations
  label_df <- plot_df_base %>%
    summarise(
      share = round(mean(privateShare, na.rm = TRUE), 1),
      total_prevalence = mean(totalPrevalence, na.rm = TRUE),
      .by = any_of(c('indic_label', data_level_col))
    ) %>%
    mutate(
      label = paste0("Priv. share = ", share, "%"),
      # Position the text slightly above the total bar height
      y_pos_text = total_prevalence + 0.05 # Adjust offset as needed
    )

  # Define common ggplot elements
  common_plot_elements <- list(
    # Set y-axis to go from 0 to 100% (0-1 in decimal)
    scale_y_continuous(
      breaks = seq(0, 1, by = 0.1),
      labels = seq(0, 100, by = 10),
      limits = c(0, robust_max(label_df$y_pos_text, 100) * 1.1) # Max Y-limit considering text position
    ),
    scale_fill_manual(values = c("Public" = "#2196F3", "Private" = "#E91E63")), # Using more distinct blue/red
    labs(
      title = country_name,
      x = NULL, # No X-axis title
      y = "Prevalence (%)",
      fill = "Sector"
    ),
    cd_plot_theme(),
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      axis.text.x = element_text(angle = 0, hjust = 0.5), # Keep x-axis text horizontal
      panel.grid.major.x = element_blank(), # Remove vertical grid lines
      legend.position = "bottom" # Move legend to bottom as in image
    )
  )

  # Build the plot based on data_level
  if (data_level == "national") {
    p <- ggplot(long_df, aes(x = indic_label, y = value, fill = sector)) +
      geom_col(position = "stack") +
      geom_text(
        data = label_df,
        aes(x = indic_label, y = y_pos_text, label = label),
        inherit.aes = FALSE,
        size = 3.5, vjust = -0.5
      ) +
      common_plot_elements
  } else { # data_level == "area" - to match the image precisely
    p <- ggplot(long_df, aes(x = area, y = value, fill = sector)) + # X-axis is 'area' (Rural/Urban)
      geom_col(position = "stack") +
      facet_grid(. ~ indic_label, scales = "free_x", space = "free_x") + # Facet by indic_label
      geom_text(
        data = label_df,
        aes(x = area, y = y_pos_text, label = label), # Text labels mapped to 'area'
        inherit.aes = FALSE,
        size = 3.5, vjust = -0.5 # Adjust text size and vertical alignment
      ) +
      common_plot_elements +
      theme(
        panel.spacing.x = unit(0.5, "lines"), # Adjust space between facets for visual separation
        strip.background = element_rect(fill = "grey95", color = "grey95"), # Background for facet labels
        strip.text = element_text(face = "bold", size = 10) # Styling for facet titles
      )
  }

  p
}
